<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
   "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
  <!ENTITY % general-entities SYSTEM "../../general.ent">
  %general-entities;
]>

<!--

Direitos autorais (Copyright) da versão modificada traduzida para a 
língua portuguesa escrita e falada no Brasil: (c) 2022, 2023 Jamenson 
Ferreira Espindula de Almeida Melo (<jafesp@gmail.com>).

  Este trabalho de tradução do livro "Beyond Linux From Scratch" é 
  classificado pela Free Software Foundation como sendo uma "versão 
  modificada" do mencionado livro.  Em assim sendo, na qualidade de 
  tradutor, produtor da "versão modificada" e titular dos direitos 
  autorais sobre a versão traduzida para a língua portuguesa do livro 
  "Beyond Linux From Scratch", concede-se a seguinte permissão:

  É concedida permissão para copiar, distribuir e (ou) modificar este 
  livro "Beyond Linux From Scratch", versão traduzida para a língua 
  portuguesa, sob os termos da Licença de Documentação Livre GNU, versão 
  1.3 ou qualquer versão posterior publicada pela Free Software 
  Foundation; sem Seções Invariantes, sem Textos de Capa Frontal e sem 
  Textos de Quarta Capa.  Uma cópia da licença está incluída na seção 
  intitulada "Licença de Documentação Livre GNU".
  
# Atenção: todos os documentos aqui publicados são distribuídos sem qualquer garantia, implícita e (ou) explícita.
  
  Permission is granted to copy, distribute and (or) modify this book 
  "Beyond Linux From Scratch", translated into Brazilian Portuguese, 
  under the terms of the GNU Free Documentation License, Version 1.3 or 
  any later version published by the Free Software Foundation; with no 
  Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.  A 
  copy of the license is included in the section entitled "GNU Free 
  Documentation License".

# Warning: all the files herein published are released with no warranty, implicit and (or) explicit.

-->

<sect1 id="locale-issues" xreflabel="Problemas Relacionados ao Locale">
  <?dbhtml filename="locale-issues-pt_br.html"?>

  <sect1info>
    <date>$Date$</date>
  </sect1info>

  <title>Problemas Relacionados ao Locale</title>

  <para>

    Esta página contém informação acerca de situações difíceis e 
    problemas relacionados ao locale.  Nos parágrafos seguintes você 
    encontrará uma visão geral genérica das coisas que podem surgir 
    quando configurar o seu sistema para vários locales.  Muitas (mas, 
    não todas) situações difíceis existentes relacionadas ao locale 
    podem ser classificadas e caem sob um dos títulos abaixo.  As 
    avaliações de gravidade abaixo usam o seguinte critério:

  </para>

  <itemizedlist>

    <listitem>

      <para>

        Crítica: O aplicativo não realiza a função principal dele.  A 
        correção seria muito invasiva; é melhor procurar por uma 
        substituição.

      </para>

    </listitem>

    <listitem>

      <para>

        Alta: Parte da funcionalidade que o aplicativo fornece não é 
        utilizável.  Se essa funcionalidade for exigida, [então] é 
        melhor procurar por uma substituição.

      </para>

    </listitem>

    <listitem>

      <para>

        Baixa: O aplicativo funciona em todos os casos típicos de uso, 
        porém carece de alguma funcionalidade normalmente fornecida 
        pelos equivalentes dele.

      </para>

    </listitem>

  </itemizedlist>

  <para>

    Se existir uma gambiarra conhecida para um pacote específico, 
    [então] ela aparecerá naquela página do pacote.  Para a mais recente 
    informação acerca dos problemas relacionados ao locale para pacotes 
    individuais, verifique as
    <ulink url="&blfs-wiki;/BlfsNotes">Observações de Usuário(a)</ulink>
    na Wiki do BLFS.

  </para>

  <sect2 id="locale-not-valid-option"
         xreflabel="Codificação Necessária Não É uma Opção Válida">

    <title>A Codificação Necessária Não É uma Opção Válida no Aplicativo</title>

    <para>Gravidade: Crítica</para>

    <para>

      Alguns aplicativos exigem que o(a) usuário(a) especifique a 
      codificação de caracteres para os dados de entrada gerada ou de 
      saída gerada deles e apresentam somente uma escolha limitada de 
      codificações.  Esse é o caso para a opção <option>-X</option> no 
      <!-- <xref linkend="a2ps"/> e no --><xref linkend="enscript"/>; 
      para a opção <option>-input-charset</option> no
      <xref linkend="cdrtools"/> não remendado; e para os conjuntos de 
      caracteres oferecidos para exibição no menu do
      <xref linkend="Links"/>.  Se a codificação exigida não estiver na
      lista, [então] o aplicativo geralmente se torna completamente 
      inutilizável.  Para os aplicativos não interativos, talvez seja 
      possível contornar isso convertendo-se o documento para um 
      conjunto suportado de caracteres de entrada antes de submetê-lo ao 
      aplicativo.

    </para>

    <para>

      Uma solução para esse tipo de situação difícil é a de implementar 
      o suporte necessário para a codificação ausente como uma correção 
      para o aplicativo original ou encontrar um substituto.

    </para>

  </sect2>

  <sect2 id="locale-assumed-encoding"
         xreflabel="O Aplicativo Assume a Codificação">

    <title>

      O Aplicativo Assume a Codificação Baseada no Locale dos Documentos 
      Externos

    </title>

    <para>

      Gravidade: Alta para documentos não textuais; baixa para 
      documentos de texto

    </para>

    <para>

      Alguns aplicativos, <xref linkend="nano"/> ou
      <xref linkend="joe"/>, por exemplo, assumem que os documentos
      sempre estejam na codificação implícita pelo locale
      atual.  Enquanto essa presunção talvez seja válida para os
      documentos criados pelo(a) usuário(a), ela não é segura para
      os externos.  Quando essa presunção falha, os caracteres não
      ASCII são exibidos incorretamente e o documento talvez se
      torne ilegível.

    </para>

    <para>

      Se o documento externo for inteiramente baseado em texto, [então] 
      ele pode ser convertido para a codificação atual do locale 
      usando-se o aplicativo <command>iconv</command>.

    </para>

    <para>

      Para documentos que não sejam baseados em texto, isso não é 
      possível.  De fato, a presunção feita no aplicativo talvez seja 
      completamente inválida para documentos onde o sistema operacional 
      Microsoft Windows tenha configurado padrões efetivos.  Um exemplo 
      dessa situação difícil são as etiquetas ID3v1 nos arquivos MP3 
      (veja-se a
<ulink url="&blfs-wiki;/ID3v1Coding">página Codificação ID3v1 da Wiki da BLFS</ulink>
      para mais detalhes).  Para esses casos, a única solução é a de
      encontrar um aplicativo substituto que não tenha o problema (por
      exemplo, um que te permitirá especificar a codificação presumida
      do documento).

    </para>

    <para>

      Entre os pacotes do BLFS, essa situação difícil se aplica ao
      <xref linkend="nano"/>; ao <xref linkend="joe"/>; e a todos os 
      reprodutores de mídia, exceto o <xref linkend="audacious"/>.

    </para>

    <para>

      Outra situação difícil nessa categoria é quando alguém não 
      consegue ler os documentos que você enviou, pois o sistema 
      operacional dessa pessoa está configurado para manusear 
      diferentemente as codificações de caracteres.  Isso pode acontecer 
      frequentemente quando a outra pessoa estiver usando o Microsoft 
      Windows, o qual fornece apenas uma codificação de caracteres para 
      um dado país.  Por exemplo, isso causa situações difíceis com 
      documentos do TeX codificados em UTF-8 criados no Linux.  No 
      Windows, a maioria dos aplicativos assumirá que esses documentos 
      tenham sido criados usando a codificação padrão de oito (08) bits 
      do Windows.

    </para>

    <para>

      Em casos extremos, os problemas de compatibilidade de codificação 
      do Windows talvez somente sejam resolvidos executando-se os 
      aplicativos do Windows sob o
      <ulink url="http://www.winehq.com/">Wine</ulink>.

    </para>

  </sect2>

  <sect2 id="locale-wrong-filename-encoding"
         xreflabel="Codificação Errada do Nome do Arquivo">

    <title>

      O Aplicativo Usa ou Cria os Nomes de Arquivo na Codificação Errada

    </title>

    <para>Gravidade: Crítica</para>

    <para>

      O padrão POSIX manda que a codificação do nome de arquivo seja a 
      codificação implícita pela categoria de locale LC_CTYPE atual.  
      Essa informação está bem ocultada na página que especifica o 
      comportamento dos aplicativos <application>Tar</application> e 
      <application>Cpio</application>.  Alguns aplicativos obtém isso 
      errado por padrão (ou, simplesmente, não tem informação suficiente 
      para obter isso certo).  O resultado é o de que eles criam nomes 
      de arquivo que não são subsequentemente mostrados corretamente 
      pelo <command>ls</command>; ou eles se recusam a aceitar nomes de 
      arquivo que o <command>ls</command> mostra adequadamente.  Para a 
      biblioteca <xref linkend="glib2"/>, a situação difícil pode ser 
      corrigida configurando-se a variável de ambiente 
      <envar>G_FILENAME_ENCODING</envar> para o valor especial 
      "@locale".  Os aplicativos baseados na 
      <application>Glib2</application> que não respeitarem essa variável 
      de ambiente são defeituosos.

    </para>

    <para>

      O <xref linkend="zip"/> e o <xref linkend="unzip"/> tem esse 
      problema, pois eles rigidamente codificam a codificação esperada 
      de nome de arquivo.  O <application>UnZip</application> contém uma 
      tabela rigidamente codificada de conversão entre as codificações 
      CP850 (DOS) e ISO-8859-1 (UNIX) e usa essa tabela quando extrai 
      arquivamentos criados sob o DOS ou sob o Microsoft Windows.  
      Entretanto, essa presunção funciona somente para aqueles(as) nos 
      Estados Unidos da América do Norte e não para qualquer um(a) 
      usando um locale UTF-8.  Os caracteres não ASCII serão 
      desfigurados nos nomes de arquivos extraídos.

    </para>

    <!--

    <para>

      Por outro lado, o
      <application>Gravador de CD do Nautilus</application> verifica
      os nomes dos arquivos adicionados à janela dele para validade
      UTF-8.  Isso é errado para usuários(as) de locales não
      UTF-8.  Também o
      <application>Gravador de CD do Nautilus</application> chama
      incondicionalmente o <command>mkisofs</command> com o parâmetro 
      <parameter>-input-charset UTF-8</parameter>, o que é correto 
      somente em locales UTF-8.

    </para>

    -->

    <para>

      A regra geral para se evitar essa classe de problemas é a de se 
      evitar instalar aplicativos quebrados.  Se isso for impossível, 
      [então] a ferramenta de linha de comando
      <ulink url="http://j3e.de/linux/convmv/">convmv</ulink> pode ser
      usada para corrigir os nomes de arquivos criados por esses
      aplicativos quebrados; ou, intencionalmente, desfigurar os nomes
      de arquivos existentes para satisfazer as expectativas quebradas
      de tais aplicativos.

    </para>

    <para>

      Em outros casos, um problema similar é causado importando-se nomes 
      de arquivos a partir de um sistema usando um locale diferente com 
      uma ferramenta que não é ciente do locale (por exemplo, o 
      <!--<xref linkend="nfs-utils"/>; ou o-->
      <xref linkend="openssh"/>).  Para a finalidade de se evitar
      desfigurar os caracteres não ASCII quando se transferir arquivos
      para um sistema com um locale diferente, quaisquer dos seguintes
      métodos podem ser usados:

    </para>

    <itemizedlist>

      <listitem>

        <para>

          Transfira de qualquer modo; corrija o dano com o 
          <command>convmv</command>.

        </para>

      </listitem>

      <listitem>

        <para>

          No lado do(a) remetente, crie um arquivamento tar com a chave 
          <parameter>--format=posix</parameter> passada para o 
          <command>tar</command> (isso será o padrão em uma versão 
          futura do <command>tar</command>).

        </para>

      </listitem>

      <listitem>

        <para>

          Envie os arquivos como anexos de mensagem de correio 
          eletrônico.  Os clientes de correio eletrônico especificam a 
          codificação dos nomes de arquivos anexados.

        </para>

      </listitem>

      <listitem>

        <para>

          Escreva os arquivos para um disco removível formatado com um 
          sistema de arquivos FAT ou FAT32.

        </para>

      </listitem>

      <listitem>

        <para>

          Transfira os arquivos usando o Samba.

        </para>

      </listitem>

      <listitem>

        <para>

          Transfira os arquivos via FTP usando um servidor (atualmente, 
          isso significa somente o wu-ftpd, que tem um mau histórico de 
          segurança) e um cliente (por exemplo, o lftp) cientes da 
          RFC2640.

        </para>

      </listitem>

    </itemizedlist>

    <para>

      Os últimos quatro métodos funcionam, pois os nomes de arquivos são 
      convertidos automaticamente do locale do(a) remetente para UNICODE 
      e armazenados ou enviados nessa forma.  Eles são então convertidos 
      transparentemente do UNICODE para a codificação do locale do(a) 
      recipiente.

    </para>

  </sect2>

  <sect2 id="locale-wrong-multibyte-characters"
         xreflabel="Breaks Multibyte Characters">

    <title>The Program Breaks Multibyte Characters or Doesn't Count
    Character Cells Correctly</title>

    <para>Severity: High or critical</para>

    <para>Many programs were written in an older era where multibyte
    locales were not common. Such programs assume that C "char" data
    type, which is one byte, can be used to store single characters.
    Further, they assume that any sequence of characters is a valid
    string and that every character occupies a single character cell.
    Such assumptions completely break in UTF-8 locales. The visible
    manifestation is that the program truncates strings prematurely
    (i.e., at 80 bytes instead of 80 characters). Terminal-based
    programs don't place the cursor correctly on the screen, don't react
    to the "Backspace" key by erasing one character, and leave junk
    characters around when updating the screen, usually turning the
    screen into a complete mess.</para>

    <para>Fixing this kind of problems is a tedious task from a
    programmer's point of view, like all other cases of retrofitting new
    concepts into the old flawed design. In this case, one has to redesign
    all data structures in order to accommodate to the fact that a complete
    character may span a variable number of "char"s (or switch to wchar_t
    and convert as needed). Also, for every call to the "strlen" and
    similar functions, find out whether a number of bytes, a number of
    characters, or the width of the string was really meant. Sometimes it
    is faster to write a program with the same functionality from scratch.
    </para>

    <para>Among BLFS packages, this problem applies to
    <xref linkend="xine-ui"/> and all the shells.</para>

  </sect2>

  <sect2 id="locale-wrong-manpage-encoding"
         xreflabel="Incorrect Manual Page Encoding">

    <title>The Package Installs Manual Pages in Incorrect or
    Non-Displayable Encoding</title>

    <para>Severity: Low</para>

    <para>LFS expects that manual pages are in the language-specific (usually
    8-bit) encoding, as specified on the <ulink
    url="&lfs-root;/chapter08/man-db.html">LFS Man DB page</ulink>. However,
    some packages install translated manual pages in UTF-8 encoding (e.g.,
    Shadow, already dealt with), or manual pages in languages not in the table.
    Not all BLFS packages have been audited for conformance with the
    requirements put in LFS (the large majority have been checked, and fixes
    placed in the book for packages known to install non-conforming manual
    pages). If you find a manual page installed by any of BLFS packages that is
    obviously in the wrong encoding, please remove or convert it as needed, and
    report this to BLFS team as a bug.</para>

    <para>You can easily check your system for any non-conforming manual pages
    by copying the following short shell script to some accessible location,

<screen><literal>#!/bin/sh
# Begin checkman.sh
# Usage: find /usr/share/man -type f | xargs checkman.sh
for a in "$@"
do
    # echo "Checking $a..."
    # Pure-ASCII manual page (possibly except comments) is OK
    grep -v '.\\"' "$a" | iconv -f US-ASCII -t US-ASCII >/dev/null 2>&amp;1 \
        &amp;&amp; continue
    # Non-UTF-8 manual page is OK
    iconv -f UTF-8 -t UTF-8 "$a" >/dev/null 2>&amp;1 || continue
    # Found a UTF-8 manual page, bad.
    echo "UTF-8 manual page: $a" >&amp;2
done
# End checkman.sh
</literal></screen>

    and then issuing the following command (modify the command below if the
    <command>checkman.sh</command> script is not in your <envar>PATH</envar>
    environment variable):</para>

<screen><userinput>find /usr/share/man -type f | xargs checkman.sh</userinput></screen>

    <para>Note that if you have manual pages installed in any location other
    than <filename class='directory'>/usr/share/man</filename> (e.g.,
    <filename class='directory'>/usr/local/share/man</filename>), you must
    modify the above command to include this additional location.</para>

  </sect2>

</sect1>
