<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
   "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
  <!ENTITY % general-entities SYSTEM "../../general.ent">
  %general-entities;
]>

<!--

Direitos autorais (Copyright) da versão modificada traduzida para a 
língua portuguesa escrita e falada no Brasil: (c) 2022 Jamenson Ferreira 
Espindula de Almeida Melo (<jafesp@gmail.com>).

  Este trabalho de tradução do livro "Beyond Linux From Scratch" é 
  classificado pela Free Software Foundation como sendo uma "versão 
  modificada" do mencionado livro.  Em assim sendo, na qualidade de 
  tradutor, produtor da "versão modificada" e titular dos direitos 
  autorais sobre a versão traduzida para a língua portuguesa do livro 
  "Beyond Linux From Scratch", concede-se a seguinte permissão:

  É concedida permissão para copiar, distribuir e (ou) modificar este 
  livro "Beyond Linux From Scratch", versão traduzida para a língua 
  portuguesa, sob os termos da Licença de Documentação Livre GNU, versão 
  1.3 ou qualquer versão posterior publicada pela Free Software 
  Foundation; sem Seções Invariantes, sem Textos de Capa Frontal e sem 
  Textos de Quarta Capa.  Uma cópia da licença está incluída na seção 
  intitulada "Licença de Documentação Livre GNU".
  
# Atenção: todos os documentos aqui publicados são distribuídos sem qualquer garantia, implícita e (ou) explícita.
  
  Permission is granted to copy, distribute and (or) modify this book 
  "Beyond Linux From Scratch", translated into Brazilian Portuguese, 
  under the terms of the GNU Free Documentation License, Version 1.3 or 
  any later version published by the Free Software Foundation; with no 
  Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.  A 
  copy of the license is included in the section entitled "GNU Free 
  Documentation License".

# Warning: all the files herein published are released with no warranty, implicit and (or) explicit.

-->

<sect1 id="unpacking">
  <?dbhtml filename="notes-on-building-pt_br.html"?>

  <sect1info>
    <date>$Date$</date>
  </sect1info>

  <title>Observações Acerca de Construir Software</title>

  <para>

    Aquelas pessoas que tenham construído um sistema LFS talvez estejam 
    cientes dos princípios gerais da transferência e do desempacotamento 
    de software.  Alguma daquela informação está repetida aqui para 
    aquelas novatas em construir o próprio software delas.

  </para>

  <para>

    Cada conjunto de instruções de instalação contém um URL a partir do 
    qual você pode transferir o pacote.  As correções, no entanto, estão 
    armazenadas nos servidores do LFS e estão disponíveis via HTTP.  
    Essas estão referenciadas conforme necessárias nas instruções de 
    instalação.

  </para>

  <para>

    Enquanto você pode manter os arquivos do fonte em qualquer lugar que 
    queira, nós assumimos que você desempacotou o pacote e mudou para o 
    diretório criado pelo processo de desempacotamento (o diretório de 
    'construção').  Nós assumimos também que você descomprimiu quaisquer 
    correções exigidas e que elas estão no diretório imediatamente acima 
    do diretório de 'construção'.

  </para>

  <para>

    Nós não podemos enfatizar fortemente o suficiente que você deveria 
    iniciar a partir de uma <emphasis>árvore limpa do fonte</emphasis> a 
    cada vez.  Isso significa que, se você tiver tido um erro durante a 
    configuração ou a compilação, [então] geralmente é melhor deletar a 
    árvore do fonte e desempacotá-la outra vez
    <emphasis>antes de</emphasis> tentar novamente.  Isso, obviamente,
    não se aplica se você for um(a) usuário(a) avançado(a) habituado(a)
    a hackear <filename>Makefile</filename>s e código C; porém, se em
    dúvida, [então] inicie a partir de uma árvore limpa.

  </para>

  <sect2>
    <title>Construindo Software como um(a) Usuário(a) Não Privilegiado(a) (não root)</title>

    <para>

      A regra de ouro da Administração do Sistema Unix é a de usar os 
      seus super poderes somente quando necessário.  Assim, o BLFS 
      recomenda que você construa software como um(a) usuário(a) não 
      privilegiado(a) e somente se torne o(a) usuário(a)
      <systemitem class='username'>root</systemitem> quando instalar
      o software.  Essa filosofia é seguida em todos os pacotes neste
      livro.  A menos que especificado de outra maneira, todas as
      instruções deveriam ser executadas como um(a) usuário(a) não
      privilegiado(a).  O livro alertará você acerca de instruções
      que precisarem de privilégios do(a)
      <systemitem class='username'>root</systemitem>.

    </para>

  </sect2>

  <sect2>
    <title>Desempacotando o Software</title>

    <para>

      Se um arquivo estiver no formato
      <filename class='extension'>.tar</filename> e comprimido, [então]
      ele é desempacotado executando-se um dos seguintes comandos:

    </para>

<screen><userinput>tar -xvf nome_do_arquivo.tar.gz
tar -xvf nome_do_arquivo.tgz
tar -xvf nome_do_arquivo.tar.Z
tar -xvf nome_do_arquivo.tar.bz2</userinput></screen>

    <note>

      <para>

        Você talvez omita o uso do parâmetro <option>v</option> nos 
        comandos mostrados acima e abaixo se você desejar suprimir a 
        listagem verbosa de todos os arquivos no arquivamento conforme 
        eles forem extraídos.  Isso pode ajudar a acelerar a extração, 
        bem como torna quaisquer erros produzidos durante a extração 
        mais óbvios para você.

      </para>

    </note>

    <para>Você também pode usar um método ligeiramente diferente:</para>

<screen><userinput>bzcat nome_do_arquivo.tar.bz2 | tar -xv</userinput></screen>

    <para>

      Finalmente, as vezes você precisa estar apto(a) a desempacotar 
      correções que geralmente não estão no formato
      <filename class='extension'>.tar</filename>.  A melhor maneira de
      fazer isso é a de copiar o arquivo da correção para o pai do
      diretório da 'construção' e, então, executar um dos seguintes
      comandos, dependendo se o arquivo for um arquivo
      <filename class='extension'>.gz</filename> ou um
      <filename class='extension'>.bz2</filename>:

    </para>

<screen><userinput>gunzip -v nome_da_correcao.gz
bunzip2 -v nome_da_correcao.bz2</userinput></screen>

  </sect2>

  <sect2>
    <title>Averiguando a Integridade do Arquivo</title>

    <para>

      Geralmente, para se averiguar se o arquivo transferido está 
      completo, muitos(as) mantenedores(as) de pacote também distribuem 
      somas de md5 dos arquivos.  Para averiguar a soma de md5 dos 
      arquivos transferidos, transfira ambos, o arquivo e o arquivo 
      correspondente de soma de md5, para o mesmo diretório 
      (preferencialmente a partir de locais diferentes online) e 
      (assumindo que <filename>arquivo.md5sum</filename> seja o arquivo 
      de soma de md5 transferido) execute o seguinte comando:

    </para>

<screen><userinput>md5sum -c arquivo.md5sum</userinput></screen>

    <para>

      Se existirem quaisquer erros, [então] eles serão relatados.  
      Observe que o livro BLFS inclui somas de md5 para todos os 
      arquivos de fonte também.  Para usar as somas de md5 fornecidas 
      pelo BLFS, você pode criar um <filename>arquivo.md5sum</filename> 
      (coloque os dados da soma de md5 e o nome exato do arquivo 
      transferido na mesma linha de um arquivo, separados por espaço em 
      branco) e executar o comando mostrado acima.  Alternativamente, 
      simplesmente execute o comando mostrado abaixo e compare a saída 
      gerada para os dados da soma de md5 mostrada no livro BLFS.

    </para>

<screen><userinput>md5sum <replaceable>&lt;nome_do_arquivo_transferido&gt;</replaceable></userinput></screen>

    <para>

      MD5 não é seguro criptograficamente, de forma que as somas de md5 
      são fornecidas apenas para se detectar mudanças não maliciosas 
      para o conteúdo do arquivo.  Por exemplo, um erro ou truncamento 
      introduzido durante a transferência de rede; ou uma atualização 
      <quote>furtiva</quote> para o pacote oriunda do(a) 
      desenvolvedor(a) (atualizando o conteúdo de um tarball liberado em 
      vez de fazer um lançamento novo adequadamente).

    </para>

    <para>

      Não existe maneira <quote>100%</quote> segura de garantir a 
      genuinidade dos arquivos do fonte.  Assumindo que o(a) 
      desenvolvedor(a) esteja gerenciando corretamente o sítio da web 
      dele(a) (a chave privada não vazou e o domínio não esteja 
      sequestrado); e que as âncoras de confiança tenham sido 
      configuradas corretamente usando <xref linkend="make-ca"/> no 
      sistema BLFS; nós podemos razoavelmente confiar nos URLs de 
      transferência para o sítio oficial da web do(a) desenvolvedor(a) 
      <emphasis role="bold">com protocolo https</emphasis>.  Observe que 
      o próprio livro BLFS está publicado em um sítio da web com https, 
      de forma que você já deveria ter alguma confiança no protocolo 
      https ou você não confiaria no conteúdo do livro.

    </para>

    <para>

      Se o pacote for transferido a partir de um local não oficial (por 
      exemplo, um espelho local), [então] as somas de verificação 
      geradas por algoritmos de resumo criptograficamente seguros (por 
      exemplo, SHA256) podem ser usadas para averiguar a genuinidade do 
      pacote.  Transfira o arquivo da soma de verificação a partir do 
      sítio da web <emphasis role="bold">oficial</emphasis> do(a) 
      desenvolvedor(a) (ou algum lugar que
      <emphasis role="bold">você possa confiar</emphasis>) e compare a
      soma de verificação do pacote oriunda do local não oficial com
      ele.  Por exemplo, a soma de verificação SHA256 pode ser
      verificada com o comando:

    </para>

    <note>

      <para>

        Se a soma de verificação e o pacote forem transferidos a partir 
        do mesmo local não confiável, [então] você não ganharia 
        melhoramento de segurança averiguando o pacote com a soma de 
        verificação.  O(A) atacante pode falsear a soma de verificação 
        assim como comprometer o próprio pacote.

      </para>

    </note>

<screen><userinput>sha256sum -c <replaceable>arquivo</replaceable>.sha256sum</userinput></screen>

    <para>

      Se o <xref linkend="gnupg2"/> estiver instalado, [então] você 
      também pode averiguar a genuinidade do pacote com uma assinatura 
      GPG.  Importe a chave pública GPG do(a) desenvolvedor(a) com:

    </para>

<screen><userinput>gpg --recv-key <replaceable>ID_da_chave</replaceable></userinput></screen>

    <para>

      <replaceable>ID_da_chave</replaceable> deveria ser substituído 
      pelo ID da chave oriundo de algum lugar que
      <emphasis role="bold">você possa confiar</emphasis> (por exemplo,
      copie-o a partir do sítio da web oficial do(a) desenvolvedor(a)
      usando https).  Agora, você pode averiguar a assinatura com:

    </para>

<screen><userinput>gpg --recv-key <replaceable>arquivo</replaceable>.sig <replaceable>arquivo</replaceable></userinput></screen>

    <para>

      A vantagem da assinatura <application>GnuPG</application> é, tão 
      logo você importou uma chave pública que possa ser confiada, você 
      pode transferir ambos, o pacote e a assinatura dele, a partir do 
      mesmo local não oficial e averiguá-los com a chave pública.  
      Assim, você não precisaria conectar com o sítio da web oficial 
      do(a) desenvolvedor(a) para ir buscar uma soma de verificação para 
      cada lançamento novo.  Você somente precisa atualizar a chave 
      pública se ela estiver expirada ou revogada.

    </para>

  </sect2>

  <sect2>
    <title>Criando Arquivos de Registro Durante a Instalação</title>

    <para>

      Para pacotes mais largos, é conveniente se criar arquivos de 
      registro em vez de olhar fixamente para a tela esperando pegar um 
      erro ou aviso em particular.  Os arquivos de registro também são 
      úteis para depuração e para manter registros.  O seguinte comando 
      permite a você criar um registro da instalação.  Substitua 
      <replaceable>&lt;comando&gt;</replaceable> pelo comando que você 
      pretende executar.

    </para>

<screen><userinput>( <replaceable>&lt;comando&gt;</replaceable> 2&gt;&amp;1 | tee compilar.log &amp;&amp; exit $PIPESTATUS )</userinput></screen>

    <para>

      <option>2&gt;&amp;1</option> redireciona as mensagens de erro para 
      o mesmo local que a saída gerada padrão.  O comando 
      <command>tee</command> permite visualizar a saída gerada enquanto 
      se registra os resultados em um arquivo.  Os parênteses em volta 
      do comando executam o comando inteiro em um subshell; e, 
      finalmente, o comando <command>exit $PIPESTATUS</command> garante 
      que o resultado do <replaceable>&lt;comando&gt;</replaceable> seja 
      retornado como o resultado e não o resultado do comando 
      <command>tee</command>.

    </para>

  </sect2>

  <sect2 id="parallel-builds" xreflabel="Usando Múltiplos Processadores">
    <title>Usando Múltiplos Processadores</title>

    <para>

      Para muitos sistemas modernos com múltiplos processadores (ou 
      núcleos) o tempo de compilação para um pacote pode ser reduzido 
      realizando-se um "make paralelo", ou configurando-se uma variável 
      de ambiente, ou dizendo-se ao aplicativo make quantos 
      processadores estão disponíveis.  Por exemplo, um Core2Duo pode 
      suportar dois processos simultâneos com:

    </para>

    <screen><userinput>export MAKEFLAGS='-j2'</userinput></screen>

    <para>

      ou apenas construir com:

    </para>

    <screen><userinput>make -j2</userinput></screen>

    <para>

      Se você tiver aplicado o <command>sed</command> opcional quando da 
      construção do <application>ninja</application> no LFS, [então] 
      você pode usar:

    </para>

    <screen><userinput>export NINJAJOBS=2</userinput></screen>

    <para>

      quando um pacote usar o <command>ninja</command>; ou apenas:

    </para>

    <screen><userinput>ninja -j2</userinput></screen>

    <para>

      porém, para o ninja, o número padrão de trabalhos é &lt;N&gt;+2, 
      onde &lt;N&gt; é o número de processadores disponíveis, de forma 
      que usar os comandos acima é preferencialmente para limitar o 
      número de trabalhos (veja-se abaixo para o porque isso poderia ser 
      necessário).

    </para>

    <para>

      Geralmente o número de processos não deveria exceder o número de 
      núcleos suportados pela CPU.  Para listar os processadores em seu 
      sistema, emita:
      <userinput>grep processor /proc/cpuinfo</userinput>.

    </para>

    <para>

      Em alguns casos, usar múltiplos processos talvez resulte em uma 
      condição de 'corrida' onde o sucesso da construção depende da 
      ordem dos comandos executados pelo aplicativo 
      <command>make</command>.  Por exemplo, se um executável precisar 
      do Arquivo A e do Arquivo B, [então] tentar-se vincular o 
      aplicativo antes que um dos componentes dependentes esteja 
      disponível resultará em uma falha.  Essa condição geralmente 
      surge, pois o(a) desenvolvedor(a) do aplicativo não designou 
      adequadamente todos os pré requisitos necessários para realizar um 
      passo no Makefile.

    </para>

    <para>

      Se isso ocorrer, [então] a melhor maneira de se proceder é a de se 
      voltar para uma construção de processador único.  Adicionar '-j1' 
      a um comando make substituirá a configuração semelhante na 
      variável de ambiente <envar>MAKEFLAGS</envar>.

    </para>

    <note>

      <para>

        Quando se executar os testes de pacote ou a porção install do 
        processo de construção do pacote, nós não recomendamos usar uma 
        opção maior que '-j1', a menos que especificado de outra 
        maneira.  Os procedimentos ou verificações da instalação não 
        foram validados usando-se procedimentos paralelos e talvez 
        falhem com problemas que são difíceis de se depurar.

      </para>

    </note>

    <important>

      <para>

        Outro problema talvez ocorra com CPUs modernas, as quais tem um 
        monte de núcleos.  Cada trabalho iniciado consome memória e, se 
        a soma da memória necessária para cada trabalho exceder da 
        memória disponível, [então] você talvez encontre, ou uma 
        interrupção de kernel Out of Memory (OOM), ou troca intensa, que 
        retardará a construção além de limites razoáveis.

      </para>

      <para>

        Algumas compilações com o <command>g++</command> talvez consumam 
        até 2,5 GB de memória, de forma que, para estar seguro(a), você 
        deveria restringir o número de trabalhos a (Memória Total em 
        GB)/2,5, ao menos para pacotes grandes, tais como o LLVM; o 
        WebKitGtk; o QtWebEngine; ou o libreoffice.

      </para>

    </important>

  </sect2>

  <sect2 id="automating-builds" xreflabel="Procedimentos Automatizados de Construção">
    <title>Procedimentos Automatizados de Construção</title>

    <para>

      Existem ocasiões onde automatizar a construção de um pacote pode 
      vir a calhar.  Todo mundo tem razões próprias para querer 
      automatizar a construção e todo mundo faz isso de maneira própria.  
      Criar <filename>Makefile</filename>s; scripts do 
      <application>Bash</application>; scripts do 
      <application>Perl</application>; ou, simplesmente, uma lista de 
      comandos usados para recortar e colar, são apenas alguns dos 
      métodos que você pode usar para automatizar a construção de 
      pacotes do BLFS.  Detalhar como e fornecer exemplos das muitas 
      maneiras que você pode automatizar a construção de pacotes está 
      além do escopo desta seção.  Esta seção exporá você ao uso do 
      redirecionamento de arquivo e do comando <command>yes</command> 
      para ajudar a fornecer ideias acerca do como automatizar suas 
      construções.

    </para>

    <bridgehead renderas="sect3">Redirecionamento de Arquivo para Automatizar a Entrada</bridgehead>

    <para>

      Você achará ocasiões ao longo da sua jornada BLFS quando você se 
      deparará com um pacote que tenha um comando solicitando 
      informação.  Essa informação poderia ser detalhes de configuração; 
      um caminho de diretório; ou uma resposta a um acordo de licença.  
      Isso pode apresentar um desafio para automatizar a construção 
      desse pacote.  Ocasionalmente, você será consultado(a) para 
      diferentes informações em uma série de perguntas.  Um método para 
      automatizar esse tipo de cenário exige colocar as respostas 
      desejadas em um arquivo e usar redirecionamento, de forma que o 
      aplicativo use os dados no arquivo como as respostas para as 
      perguntas.

    </para>

    <para>

      Construir o pacote <application>CUPS</application> é um bom 
      exemplo de como redirecionar um arquivo como entrada para 
      solicitações pode te ajudar a automatizar a construção.  Se você 
      executar a suíte de teste, [então] você é solicitado(a) a 
      responder a uma série de perguntas relacionadas ao tipo do teste a 
      executar e se você tem quaisquer aplicativos auxiliares que o 
      teste possa usar.  Você pode criar um arquivo com as suas 
      respostas, uma resposta por linha, e usar um comando similar ao 
      mostrado abaixo para automatizar a execução da suíte de teste:

    </para>

<screen><userinput>make check &lt; ../cups-1.1.23-testsuite_parms</userinput></screen>

    <para>

      Isso, efetivamente, faz com que a suíte de teste use as respostas 
      no arquivo como a entrada gerada para as perguntas.  
      Ocasionalmente você talvez termine fazendo um bocado de tentativa 
      e erro para determinar o formato exato do seu arquivo de entrada 
      gerada para algumas coisas, porém, tão logo determinado e 
      documentado, você pode usar isso para automatizar a construção do 
      pacote.

    </para>

    <bridgehead renderas="sect3">Usando o <command>yes</command> para Automatizar a Entrada Gerada</bridgehead>

    <para>

      As vezes você somente precisará fornecer uma resposta, ou fornecer 
      a mesma resposta para muitas solicitações.  Para tais instâncias, 
      o comando <command>yes</command> funciona realmente bem.  O 
      comando <command>yes</command> pode ser usado para fornecer uma 
      resposta (a mesma) para uma ou mais instâncias de perguntas.  Ele 
      pode ser usado para simular o pressionamento apenas da tecla 
      <keycap>Enter</keycap>; informar a tecla <keycap>Y</keycap>; ou 
      informar uma sequência de caracteres de texto.  Talvez a maneira 
      mais fácil de mostrar o uso dele é em um exemplo.

    </para>

    <para>

      Primeiro, crie um script curto do <application>Bash</application> 
      informando os seguintes comandos:

    </para>

<screen><userinput>cat &gt; blfs-yes-test1 &lt;&lt; "EOF"
<literal>#!/bin/bash

echo -n -e "\n\nPor favor, digite algo (ou nada) e pressione Enter ---> "

read A_STRING

if test "$A_STRING" = ""; then A_STRING="Apenas a tecla Enter foi pressionada"
else A_STRING="Você informou '$A_STRING'"
fi

echo -e "\n\n$A_STRING\n\n"</literal>
EOF
chmod 755 blfs-yes-test1</userinput></screen>

    <para>

      Agora execute o script emitindo 
      <command>./blfs-yes-test1</command> a partir da linha de comando.  
      Ele aguardará por uma resposta, que pode ser algo (ou nada) 
      seguida pela tecla <keycap>Enter</keycap>.  Depois de informar 
      alguma coisa, o resultado será ecoado para a tela.  Agora use o 
      comando <command>yes</command> para automatizar a entrada de uma 
      resposta:

    </para>

<screen><userinput>yes | ./blfs-yes-test1</userinput></screen>

    <para>

      Perceba que canalizar o próprio <command>yes</command> para o 
      script resulta em <keycap>y</keycap> sendo passada para o script.  
      Agora tente com uma sequência de caracteres de texto:

    </para>

<screen><userinput>yes 'Este é algum texto' | ./blfs-yes-test1</userinput></screen>

    <para>

      A sequência exata de caracteres foi usada como a resposta para o 
      script.  Finalmente, tente usando uma sequência de caracteres 
      vazia (nula):

    </para>

<screen><userinput>yes '' | ./blfs-yes-test1</userinput></screen>

    <para>

      Perceba que isso resulta na passagem apenas do pressionamento da 
      tecla <keycap>Enter</keycap> para o script.  Isso é útil para 
      ocasiões quando a resposta padrão para a solicitação é suficiente.  
      Essa sintaxe é usada nas instruções do
      <xref linkend="net-tools-automate-example"/> para aceitar todos os 
      padrões para as muitas solicitações durante a etapa de 
      configuração.  Você talvez agora remova o script de teste, se 
      desejado.

    </para>

    <bridgehead renderas="sect3">Redirecionamento de Arquivo para Automatizar a Saída Gerada</bridgehead>

    <para>

      Para a finalidade de automatizar a construção de alguns pacotes, 
      especialmente aqueles que exigem que você leia um acordo de 
      licença em uma página por vez, exige-se usar um método que evite 
      ter que pressionar uma tecla para exibir cada página.  
      Redirecionar a saída gerada para um arquivo pode ser usado nessas 
      instâncias para auxiliar com a automação.  A seção anterior nesta 
      página tocou na criação de arquivos de registro da saída gerada da 
      construção.  O método de redirecionamento mostrado lá usou o 
      comando <command>tee</command> para redirecionar a saída gerada 
      para um arquivo enquanto também exibia a saída gerada na tela.  
      Aqui, a saída gerada somente será enviada para um arquivo.

    </para>

    <para>

      Novamente, a maneira mais fácil para demonstrar a técnica é 
      mostrar um exemplo.  Primeiro, emita o comando:

    </para>

<screen><userinput>ls -l /usr/bin | more</userinput></screen>

    <para>

      Certamente, você será exigido(a) a visualizar a saída gerada uma 
      página por vez, pois o filtro <command>more</command> foi usado.  
      Agora tente o mesmo comando, porém, dessa vez, redirecione a saída 
      gerada para um arquivo.  O arquivo especial 
      <filename>/dev/null</filename> pode ser usado em vez do nome de 
      arquivo mostrado, porém você não terá arquivo de registro para 
      examinar:

    </para>

<screen><userinput>ls -l /usr/bin | more &gt; redirect_test.log 2&gt;&amp;1</userinput></screen>

    <para>

      Perceba que, dessa vez, o comando imediatamente retornou ao prompt 
      do shell sem ter que paginar ao longo da saída gerada.  Você agora 
      talvez remova o arquivo de registro.

    </para>

    <para>

      O último exemplo usará o comando <command>yes</command> em 
      combinação com o redirecionamento da saída gerada para desviar-se 
      de ter que paginar ao longo da saída gerada e, então, fornecer um 
      <keycap>y</keycap> para uma solicitação.  Essa técnica poderia ser 
      usada em instâncias quando, de outra maneira, você teria que 
      paginar ao longo da saída gerada de um arquivo (como um acordo de 
      licença) e, então, responder à pergunta de
      <quote>você aceita o acima?</quote>.  Para esse exemplo, outro
      script curto do <application>Bash</application> é exigido:

    </para>

<screen><userinput>cat &gt; blfs-yes-test2 &lt;&lt; "EOF"
<literal>#!/bin/bash

ls -l /usr/bin | more

echo -n -e "\n\nVocê curtiu ler isso? (y,n) "

read A_STRING

if test "$A_STRING" = "y"; then A_STRING="Você digitou a tecla 'y'"
else A_STRING="Você NÃO digitou a tecla 'y'"
fi

echo -e "\n\n$A_STRING\n\n"</literal>
EOF
chmod 755 blfs-yes-test2</userinput></screen>

    <para>

      Esse script pode ser usado para simular um aplicativo que exige 
      que você leia um acordo de licença, então responda apropriadamente 
      que aceita o acordo antes do aplicativo instalar qualquer coisa.  
      Primeiro, execute o script sem quaisquer técnicas de automação 
      emitindo <command>./blfs-yes-test2</command>.

    </para>

    <para>

      Agora emita o seguinte comando que usa duas técnicas de automação, 
      tornando-o adequado para uso em um script automatizado de 
      construção:

    </para>

<screen><userinput>yes | ./blfs-yes-test2 &gt; blfs-yes-test2.log 2&gt;&amp;1</userinput></screen>

    <para>

      Se desejado, emita <command>tail blfs-yes-test2.log</command> para 
      ver o final da saída gerada paginada e confirmação de que 
      <keycap>y</keycap> foi passada ao longo para o script.  Tão logo 
      satisfeito que ele funciona como deveria, você talvez remova o 
      script e arquivo de registro.

    </para>

    <para>

      Finalmente, tenha em mente que existem muitas maneiras de 
      automatizar e (ou) roteirizar os comandos de construção.  Não 
      existe uma maneira única <quote>correta</quote> para fazê-lo.  Sua 
      imaginação é o único limite.

    </para>

  </sect2>

  <sect2>
    <title>Dependências</title>

    <para>

      Para cada pacote descrito, o BLFS lista as dependências 
      conhecidas.  Essas são listadas sob vários títulos, cujo 
      significado é como segue:

    </para>

    <itemizedlist>

      <listitem>

        <para>

          <emphasis>Exigida</emphasis> significa que o pacote alvo não 
          pode ser corretamente construído sem a dependência sendo 
          primeiro instalada.

        </para>

      </listitem>

      <listitem>

        <para>

          <emphasis>Recomendada</emphasis> significa que o BLFS 
          enfaticamente sugere que esse pacote seja instalado primeiro 
          para uma construção limpa e livre de problemas; que não teria 
          problemas seja durante o processo de construção, seja em tempo 
          de execução.  As instruções no livro assumem que esses pacotes 
          estão instalados.  Algumas mudanças ou gambiarras talvez sejam 
          exigidas se esses pacotes não estiverem instalados.

        </para>

      </listitem>

      <listitem>

        <para>

          <emphasis>Opcional</emphasis> significa que esse pacote 
          poderia estar instalado para funcionalidade adicionada.  
          Frequentemente o BLFS descreverá a dependência para explicar a 
          funcionalidade adicionada que resultará.

        </para>

      </listitem>

    </itemizedlist>

  </sect2>

  <sect2 id="package_updates">
    <title>Usando os Fontes de Pacote Mais Atuais</title>

    <para>

      Ocasionalmente você talvez se encontre em uma situação no livro 
      onde um pacote não construirá ou não funcionará adequadamente.  
      Apesar dos(as) Editores(as) tentarem garantir que cada pacote no 
      livro construa e funcione adequadamente, as vezes um pacote tenha 
      sido negligenciado ou não foi testado com esta versão particular 
      do BLFS.

    </para>

    <para>

      Se você descobrir que um pacote não construirá ou não funcionará 
      adequadamente, [então] você deveria ver se existe uma versão mais 
      recente do pacote.  Tipicamente isso significa você ir ao sítio da 
      web do(a) mantenedor(a); e transferir o tarball mais recente; e 
      tentar construir o pacote.  Se você não puder determinar o sítio 
      da web do(a) mantenedor(a) olhando para os URLs de transferência, 
      [então] use o Google e consulte o nome do pacote.  Por exemplo, na 
      barra de pesquisa do Google, digite: 'nome_do_pacote download' 
      (omita as aspas) ou algo semelhante.  As vezes, digitar: 
      'nome_do_pacote home page' resultará em você encontrar o sítio da 
      web do(a) mantenedor(a).

    </para>

  </sect2>

  <sect2 id="stripping">
    <title>Despojando Mais Uma Vez</title>

    <warning>

      <para>

        Se você não despojou aplicativos e bibliotecas no LFS, [então] o 
        seguinte provavelmente tornará o seu sistema inutilizável.  Para 
        evitar isso, execute as instruções em
        <ulink url="&lfs-root;/chapter08/strippingagain.html"/> em vez
        disso.  Depois que os arquivos críticos estiverem despojados
        usando aquelas instruções, as instruções abaixo podem ser
        executadas a qualquer tempo que novos pacotes sejam instalados.

      </para>

    </warning>

    <para>

      No LFS, o despojamento dos simbolos de depuração foi discutido um 
      par de vezes.  Quando se construir pacotes do BLFS, geralmente não 
      existem instruções especiais que discutam o despojamento 
      novamente.  Provavelmente, não é uma boa ideia despojar um 
      executável ou uma biblioteca enquanto ele(a) estiver em uso, de 
      forma que sair-se de qualquer ambiente de janela é uma boa ideia.  
      Então você pode fazer:

    </para>

<screen><userinput>find /usr/{bin,lib,sbin} \
    -type f \( -name \*.so* -a ! -name \*dbg \) \
    -exec strip --strip-unneeded {} \;</userinput></screen>

    <para>

      Se você instalar aplicativos em outros diretórios, tais como 
      <filename class="directory">/opt</filename> ou
      <filename class="directory">/usr/local</filename>, [então] você
      talvez queira despojar os arquivos lá também.

    </para>

    <para>

      Para mais informação acerca de despojamento, veja-se
      <ulink url="http://www.technovelty.org/linux/stripping-shared-libraries.html"/>.

    </para>

  </sect2>

<!--
  <sect2 id="libtool">
    <title>Arquivos Libtool</title>

    <para>

      Um dos efeitos colaterais de pacotes que usam o Autotools, 
      incluindo o libtool, é que eles criam muitos arquivos com uma 
      extensão .la.  Esses arquivos não são necessários em um ambiente 
      LFS.  Se existirem conflitos com as entradas do pkgconfig, [então] 
      eles atualmente podem evitar construções exitosas.  Você talvez 
      queira considerar remover esses arquivos periodicamente:

    </para>

<screen><userinput>find /lib /usr/lib -not -path "*Image*" -a -name \*.la -delete</userinput></screen>

    <para>

      O comando acima remove todos os arquivos .la, com exceção daqueles 
      que tenham <quote>Image</quote> ou <quote>openldap</quote> como 
      uma parte do caminho.  Esses arquivos .la são usados pelos 
      aplicativos ImageMagick e openldap, respectivamente.  Talvez 
      existam outras exceções por pacotes fora do BLFS.

    </para>

  </sect2>
-->

  <sect2 id="buildsystems">
    <title>Trabalhando com diferentes sistemas de construção</title>

    <para>

      Existem, agora, três sistemas de construção em uso comum para 
      converter código fonte C ou C++ em aplicativos ou bibliotecas 
      compilados(as) e os detalhes deles (particularmente, descobrir 
      acerca de opções disponíveis e os valores padrão delas) diferem.  
      Talvez seja mais fácil entender os problemas causados por algumas 
      escolhas (tipicamente, execução lenta; ou uso inesperado de, ou 
      omissão de, otimizações) iniciando-se com as variáveis de ambiente 
      CFLAGS e CXXFLAGS.  Também existem alguns aplicativos que usam 
      rust.

    </para>

    <para>

      A maioria dos(as) construtores(as) do LFS e do BLFS provavelmente 
      está ciente dos básicos de CFLAGS e CXXFLAGS para alterar como um 
      aplicativo é compilado.  Tipicamente, alguma forma de otimização é 
      usada pelos(as) desenvolvedores(as) de aplicativos (-O2 ou -O3), 
      as vezes com a criação de simbolos de depuração (-g), como 
      padrões.

    </para>

    <para>

      Se existirem sinalizadores contraditórios (por exemplo, múltiplos 
      valores -O), [então] o <emphasis>último</emphasis> valor será 
      usado.  As vezes, isso significa que os sinalizadores 
      especificados em variáveis de ambiente serão escolhidos antes dos 
      valores codificados rigidamente no Makefile, e, portanto, 
      ignorados.  Por exemplo, onde um(a) usuário(a) especificar '-O2' e 
      isso for seguido por '-O3', a construção usará '-O3'.

    </para>

    <para>

      Existem várias outras coisas que podem ser passadas em CFLAGS ou 
      em CXXFLAGS, tais como forçar-se a compilação para uma 
      microarquitetura específica (por exemplo, -march=amdfam10; 
      -march=native) ou especificar-se um padrão específico para C ou 
      C++ (-std=c++17, por exemplo).  Porém, uma coisa que agora veio à 
      tona é que os(as) programadores(as) poderiam incluir asserções de 
      depuração no código deles(as), esperando que sejam desabilitados 
      em lançamentos usando-se -DNDEBUG.  Especificamente, se o
      <xref linkend="mesa"/> for construído com essas asserções
      habilitadas, [então] algumas atividades, tais como o carregamento
      de níveis dos jogos, podem tomar tempos extremamente longos,
      mesmo em placas de vídeo de alta qualidade.

    </para>

    <bridgehead renderas="sect3" id="autotools-info">Autotools with Make</bridgehead>

      <para>
       This combination is often described as 'CMMI' (configure, make, make
       install) and is used here to also cover the few packages which have a
       configure script that is not generated by autotools.
      </para>

      <para>
        Sometimes running <command>./configure --help</command> will produce
        useful options about switches which might be used.  At other times,
        after looking at the output from configure you may need to look
        at the details of the script to find out what it was actually searching
        for.
      </para>

      <para>
       Many configure scripts will pick up any CFLAGS or CXXFLAGS from the
       environment, but CMMI packages vary about how these will be mixed with
       any flags which would otherwise be used (<emphasis>variously</emphasis>:
       ignored, used to replace the programmer's suggestion, used before the
       programmer's suggestion, or used after the programmer's suggestion).
      </para>

      <para>
       In most CMMI packages, running 'make' will list each command and run
       it, interspersed with any warnings. But some packages try to be 'silent'
       and only show which file they are compiling or linking instead of showing
       the command line. If you need to inspect the command, either because of
       an error, or just to see what options and flags are being used, adding
       'V=1' to the make invocation may help.
     </para>

    <bridgehead renderas="sect3" id="cmake-info">CMake</bridgehead>

      <para>
        CMake works in a very different way, and it has two backends which can
        be used on BLFS: 'make' and 'ninja'. The default backend is make, but
        ninja can be faster on large packages with multiple processors. To
        use ninja, specify '-G Ninja' in the cmake command. However, there are
        some packages which create fatal errors in their ninja files but build
        successfully using the default of Unix Makefiles.
      </para>

      <para>
        The hardest part of using CMake is knowing what options you might wish
        to specify. The only way to get a list of what the package knows about
        is to run <command>cmake -LAH</command> and look at the output for that
        default configuration.
      </para>

      <para>
        Perhaps the most-important thing about CMake is that it has a variety
        of CMAKE_BUILD_TYPE values, and these affect the flags. The default
        is that this is not set and no flags are generated. Any CFLAGS or
        CXXFLAGS in the environment will be used. If the programmer has coded
        any debug assertions, those will be enabled unless -DNDEBUG is used.
        The following CMAKE_BUILD_TYPE values will generate the flags shown,
        and these will come <emphasis>after</emphasis> any flags in the
        environment and therefore take precedence.
      </para>

      <itemizedlist>
        <listitem>
          <para>Debug : '-g'</para>
        </listitem>
        <listitem>
          <para>Release : '-O3 -DNDEBUG'</para>
        </listitem>
        <listitem>
           <para>RelWithDebInfo : '-O2 -g -DNDEBUG'</para>
        </listitem>
        <listitem>
           <para>MinSizeRel : '-Os -DNDEBUG'</para>
        </listitem>
      </itemizedlist>

      <para>
        CMake tries to produce quiet builds. To see the details of the commands
        which are being run, use 'make VERBOSE=1' or 'ninja -v'.
      </para>

    <bridgehead renderas="sect3" id="meson-info">Meson</bridgehead>

      <para>
        Meson has some similarities to CMake, but many differences. To get
        details of the defines that you may wish to change you can look at
        <filename>meson_options.txt</filename> which is usually in the
         top-level directory.
      </para>

      <para>
        If you have already configured the package by running
        <command>meson</command> and now wish to change one or more settings,
        you can either remove the build directory, recreate it, and use the
        altered options, or within the build directory run <command>meson
        configure</command>, e.g. to set an option:
      </para>

<screen><userinput>meson configure -D&lt;some_option&gt;=true</userinput></screen>

      <para>
        If you do that, the file <filename>meson-private/cmd_line.txt</filename>
        will show the <emphasis>last</emphasis> commands which were used.
      </para>

      <para>
        Meson provides the following buildtype values, and the flags they enable
        come <emphasis>after</emphasis> any flags supplied in the environment and
        therefore take precedence.
      </para>

      <itemizedlist>
        <listitem>
          <para>plain : no added flags. This is for distributors to supply their
          own CLFAGS, CXXFLAGS and LDFLAGS. There is no obvious reason to use
          this in BLFS.</para>
        </listitem>
        <listitem>
          <para>debug : '-g' - this is the default if nothing is specified
          in either <filename>meson.build</filename> or the command line.
          However it results large and slow binaries, so we should override
          it in BLFS.</para>
        </listitem>
        <listitem>
           <para>debugoptimized : '-O2 -g' : this is the default specified in
           <filename>meson.build</filename> of some packages.</para>
        </listitem>
        <listitem>
           <para>release : '-O3 -DNDEBUG' (but occasionally a package will force
           -O2 here)</para>
        </listitem>
      </itemizedlist>

      <para>
        Although the 'release' buildtype is described as enabling -DNDEBUG, and all
        CMake Release builds pass that, it has so far only been observed (in
        verbose builds) for <xref linkend="mesa"/>. That suggests that it might
        only be used when there are debug assertions present.
      </para>

      <para>
        The -DNDEBUG flag can also be provided by passing
        <command>-Db_ndebug=true</command>.
      </para>

      <para>
        To see the details of the commands which are being run in a package using
        meson, use 'ninja -v'.
      </para>

    <bridgehead renderas="sect3" id="rust-info">Rustc and Cargo</bridgehead>

      <para>
        Most released rustc programs are provided as crates (source tarballs)
        which will query a server to check current versions of dependencies
        and then download them as necessary.  These packages are built using
        <command>cargo --release</command>. In theory, you can manipulate the
        RUSTFLAGS to change the optimize-level (default is 3, like -O3, e.g.
        <literal>-Copt-level=3</literal>) or to force it to build for the
        machine it is being compiled on, using
        <literal>-Ctarget-cpu=native</literal> but in practice this seems to
        make no significant difference.
      </para>

      <para>
        If you find an interesting rustc program which is only provided as
        unpackaged source, you should at least specify
        <literal>RUSTFLAGS=-Copt-level=2</literal> otherwise it will do an
        unoptimized compile with debug info and run <emphasis>much</emphasis>
        slower.
      </para>

      <para>
        The rust developers seem to assume that everyone will compile on a
        machine dedicated to producing builds, so by default all CPUs are used.
        This can often be worked around, either by exporting
        CARGO_BUILD_JOBS=&lt;N&gt; or passing --jobs &lt;N&gt; to cargo. For
        compiling rustc itself, specifying --jobs &lt;N&gt; on invocations of
        x.py (together with the <envar>CARGO_BUILD_JOBS</envar> environment
        variable, which looks like a "belt and braces" approach but seems to be
        necessary) mostly works. The exception is running the tests when building
        rustc, some of them will nevertheless use all online CPUs, at least as of
        rustc-1.42.0.
      </para>

  </sect2>

  <sect2 id="optimizations">
    <title>Optimizing the build</title>

      <para>
        Many people will prefer to optimize compiles as they see fit, by providing
        CFLAGS or CXXFLAGS. For an introduction to the options available with gcc
        and g++ see <ulink
        url="https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html"/> and <ulink
        url="https://gcc.gnu.org/onlinedocs/gcc/Instrumentation-Options.html"/>
        and <command>info gcc</command>.

      </para>

      <para>
        Some packages default to '-O2 -g', others to '-O3 -g', and if CFLAGS or
        CXXFLAGS are supplied they might be added to the package's defaults,
        replace the package's defaults, or even be ignored.  There are details
        on some desktop packages which were mostly current in April 2019 at
        <ulink url="https://www.linuxfromscratch.org/~ken/tuning/"/> - in
        particular, README.txt, tuning-1-packages-and-notes.txt, and
        tuning-notes-2B.txt. The particular thing to remember is that if you
        want to try some of the more interesting flags you may need to force
        verbose builds to confirm what is being used.
      </para>

      <para>
        Clearly, if you are optimizing your own program you can spend time to
        profile it and perhaps recode some of it if it is too slow. But for
        building a whole system that approach is impractical. In general,
        -O3 usually produces faster programs than -O2.  Specifying
        -march=native is also beneficial, but means that you cannot move the
        binaries to an incompatible machine - this can also apply to newer
        machines, not just to older machines. For example programs compiled for
        'amdfam10' run on old Phenoms, Kaveris, and Ryzens : but programs
        compiled for a Kaveri will not run on a Ryzen because certain op-codes
        are not present.  Similarly, if you build for a Haswell not everything
        will run on a SandyBridge.
      </para>

      <para>
        There are also various other options which some people claim are
        beneficial. At worst, you get to recompile and test, and then
        discover that in your usage the options do not provide a benefit.
      </para>

      <para>
        If building Perl or Python modules, or Qt packages which use qmake,
        in general the CFLAGS and CXXFLAGS used are those which were used by
        those 'parent' packages.
      </para>

  </sect2>

  <sect2 id="hardening">
    <title>Options for hardening the build</title>

      <para>
        Even on desktop systems, there are still a lot of exploitable
        vulnerabilities. For many of these, the attack comes via javascript
        in a browser. Often, a series of vulnerabilities are used to gain
        access to data (or sometimes to pwn, i.e. own, the machine and
        install rootkits).  Most commercial distros will apply various
        hardening measures.
      </para>

      <para>
        For hardening options which are reasonably cheap, there is some
        discussion in the 'tuning' link above (occasionally, one or more
        of these options might be inappropriate for a package). These
        options are -D_FORTIFY_SOURCE=2, -fstack-protector=strong, and
        (for C++) -D_GLIBCXX_ASSERTIONS. On modern machines these should
        only have a little impact on how fast things run, and often they
        will not be noticeable.
      </para>

      <para>
        In the past, there was Hardened LFS where gcc (a much older version)
        was forced to use hardening (with options to turn some of it off on a
        per-package basis. What is being covered here is different - first you
        have to make sure that the package is indeed using your added flags and
        not over-riding them.
      </para>

      <para>
        The main distros use much more, such as RELRO (Relocation Read Only)
        and perhaps -fstack-clash-protection. You may also encounter the
        so-called 'userspace retpoline' (-mindirect-branch=thunk etc.) which
        is the equivalent of the spectre mitigations applied to the linux
        kernel in late 2018). The kernel mitigations caused a lot of complaints
        about lost performance, if you have a production server you might wish
        to consider testing that, along with the other available options, to
        see if performance is still sufficient.
      </para>

      <para>
        Whilst gcc has many hardening options, clang/LLVM's strengths lie
        elsewhere. Some options which gcc provides are said to be less effective
        in clang/LLVM.
      </para>

  </sect2>

</sect1>
